from __future__ import annotations

from typing import Any, TypeVar

T = TypeVar("T")

# Basic function binding
def add(a: int, b: int) -> int: ...
def add3(a: int, b: int, c: int | None = ...) -> int: ...
def add_named(a: int, b: int, c: int | None = ...) -> int: ...

# Type conversions
def identity_int(x: int) -> int: ...
def identity_float(x: float) -> float: ...
def identity_bool(x: bool) -> bool: ...
def identity_str(x: str) -> str: ...
def identity_bytes(x: bytes) -> bytes: ...
def identity_optional(x: str | None) -> str | None: ...
def identity_object(x: T) -> T: ...
def int64_or_uint64(value: int) -> tuple[bool, int]: ...
def mask_u32(value: int) -> int: ...
def mask_u64(value: int) -> int: ...
def bigint_to_string(value: int) -> str: ...
def bigint_roundtrip(value: int) -> int: ...
def int_roundtrip(value: int) -> int: ...

# Bytes operations
def bytes_len(data: bytes) -> int: ...
def bytes_slice(data: bytes, start: int, end: int) -> bytes: ...
def bytes_create(value: str) -> bytes: ...
def buffer_len(data: bytes | bytearray | memoryview) -> int: ...
def buffer_sum(data: bytes | bytearray | memoryview) -> int: ...

# List operations
def list_len(lst: list[Any]) -> int: ...
def list_get(lst: list[Any], index: int) -> Any: ...
def list_sum(values: list[int]) -> int: ...
def list_create(a: int, b: int, c: int) -> list[int]: ...
def list_append(lst: list[int], value: int) -> list[int]: ...
def list_set(lst: list[int], index: int, value: int) -> list[int]: ...

# Dict operations
def dict_len(d: dict[Any, Any]) -> int: ...
def dict_get(d: dict[str, int], key: str) -> int | None: ...
def dict_create(key: str, value: int) -> dict[str, int]: ...
def dict_set(d: dict[str, int], key: str, value: int) -> dict[str, int]: ...
def dict_keys(d: dict[Any, Any]) -> list[Any]: ...

# Tuple operations
def tuple_len(t: tuple[Any, ...]) -> int: ...
def tuple_get(t: tuple[Any, ...], index: int) -> Any: ...
def tuple_create(a: int, b: int) -> tuple[int, int]: ...
def tuple_create_manual(a: int, b: int) -> tuple[int, int]: ...

# Object operations
def obj_call0(obj: Any) -> Any: ...
def obj_call1(obj: Any, arg: Any) -> Any: ...
def obj_call2(obj: Any, arg1: Any, arg2: Any) -> Any: ...
def obj_getattr(obj: Any, name: str) -> Any: ...
def obj_setattr(obj: Any, name: str, value: Any) -> bool: ...
def obj_callmethod0(obj: Any, name: str) -> Any: ...
def obj_callmethod1(obj: Any, name: str, arg: Any) -> Any: ...
def obj_is_callable(obj: Any) -> bool: ...
def obj_is_none(obj: Any) -> bool: ...

# Type checking
def is_unicode(obj: Any) -> bool: ...
def is_bytes(obj: Any) -> bool: ...
def is_bool(obj: Any) -> bool: ...
def is_int(obj: Any) -> bool: ...
def is_float(obj: Any) -> bool: ...
def is_list(obj: Any) -> bool: ...
def is_tuple(obj: Any) -> bool: ...
def is_dict(obj: Any) -> bool: ...

# Error handling
def raise_type_error() -> None: ...
def raise_value_error() -> None: ...
def raise_runtime_error() -> None: ...
def raise_zero_division() -> None: ...
def raise_overflow_error() -> None: ...
def raise_attribute_error() -> None: ...
def raise_index_error() -> None: ...
def raise_key_error() -> None: ...
def raise_memory_error() -> None: ...
def divide(a: float, b: float) -> float: ...
def raise_mapped(kind: str) -> None: ...

# Python interop
def import_math_pi() -> float: ...
def call_upper(value: str) -> str: ...

# Classes
class Adder:
    def __init__(self) -> None: ...
    def add(self, a: int, b: int) -> int: ...
    def identity(self) -> Adder: ...

class Counter:
    def __init__(self) -> None: ...
    def get(self) -> int: ...
    def increment(self) -> int: ...
    def add(self, value: int) -> int: ...
    def reset(self) -> None: ...

__all__: list[str]
